use methods :: { TEST_PROJECT_ELF , TEST_PROJECT_ID } ;
use risc0_zkvm :: { default_prover , ExecutorEnv } ;
use benchmarker ;
fn main () { tracing_subscriber :: fmt () . with_env_filter (tracing_subscriber :: filter :: EnvFilter :: from_default_env ()) . init () ; let input1 = input () ; let input2 = other_input (7) ; let env = ExecutorEnv :: builder () . write (& input1) . unwrap () . write (& input2) . unwrap () . build () . unwrap () ; let prover = default_prover () ; let mut benchmarker = benchmarker :: Benchmarker :: new () ; benchmarker . start_benchmark () ; let prove_info = prover . prove (env , TEST_PROJECT_ELF) . unwrap () ; let benchmark_results = benchmarker . end_benchmark () ; if let Some ((duration , peak_memory)) = benchmark_results { println ! ("Proving time: {:?}" , duration) ; println ! ("Peak memory consumption during proving: {} KB" , peak_memory) ; } let receipt = prove_info . receipt ; let serialized_receipt = bincode :: serialize (& receipt) . unwrap () ; let size_in_kb = serialized_receipt . len () as f64 / 1024.0 ; println ! ("Proof size: {} KB" , size_in_kb) ; let output : u32 = receipt . journal . decode () . unwrap () ; let mut verifying_benchmarker = benchmarker :: Benchmarker :: new () ; verifying_benchmarker . start_benchmark () ; receipt . verify (TEST_PROJECT_ID) . unwrap () ; let verifying_benchmark_results = verifying_benchmarker . end_benchmark () ; if let Some ((duration , peak_memory)) = verifying_benchmark_results { println ! ("Verification time: {:?}" , duration) ; println ! ("Peak memory consumption during verification: {} KB" , peak_memory) ; } }
fn input () -> u32 { 10 }
fn other_input (n : usize) -> f64 { (2 * n) as f64 }
fn other_host_function () -> f64 { 1.0 }
